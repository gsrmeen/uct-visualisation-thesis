<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>src.chess.figures API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.chess.figures</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABC, abstractmethod

from numpy import zeros

from src.chess.algorithm_relay.chess_move import ChessMove
from src.chess.enums import FigureType, Color, MoveType
from src.chess.figures_collection import ChessFiguresCollection


class Figure(ABC):
    def __init__(self, color, figure_type, image_file, position):
        self.color = color
        self.figure_type = figure_type
        self.image_file = image_file
        self.position = position
        super().__init__()

    @abstractmethod
    def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
        pass

    @staticmethod
    def is_move_valid(move_pos):
        return 0 &lt;= move_pos[0] &lt;= 7 and 0 &lt;= move_pos[1] &lt;= 7

    @staticmethod
    def get_figure(figures: ChessFiguresCollection, position):
        return figures.get_figure_at(position)

    @staticmethod
    def remove_figure_on_position(figures: ChessFiguresCollection, position):
        figures.remove_figure_at(position)

    @staticmethod
    def remove_figure(figures: ChessFiguresCollection, figure):
        return figures.remove(figure)


class FigureWithLinearMovement(Figure):
    @abstractmethod
    def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
        pass

    def check_moves_linear(self, figures: ChessFiguresCollection, directions, threat_for_king=False):
        possible_moves = []
        pos_x = self.position[0]
        pos_y = self.position[1]
        for direction in directions:
            dir_x = direction[0]
            dir_y = direction[1]
            pos_being_checked = (pos_x + dir_x, pos_y + dir_y)
            while self.is_move_valid(pos_being_checked):
                figure = figures.get_figure_at(pos_being_checked)
                if figure:
                    if figure.color != self.color or threat_for_king:
                        possible_moves.append(ChessMove(pos_being_checked, self.position, MoveType.NORMAL))
                    break
                possible_moves.append(ChessMove(pos_being_checked, self.position, MoveType.NORMAL))
                pos_being_checked = (pos_being_checked[0] + dir_x, pos_being_checked[1] + dir_y)

        return possible_moves


class Pawn(Figure):
    MOVE_SETUPS = {
        Color.WHITE: {
            &#34;start_line&#34;: 1,
            &#34;last_line&#34;: 7,
            &#34;step_forward&#34;: lambda x, step: x + step,
            &#34;step_backward&#34;: lambda x, step: x - step
        },
        Color.BLACK: {
            &#34;start_line&#34;: 6,
            &#34;last_line&#34;: 0,
            &#34;step_forward&#34;: lambda x, step: x - step,
            &#34;step_backward&#34;: lambda x, step: x + step
        }
    }

    def __init__(self, color, position):
        self.can_be_captured_en_passant = False
        self.value = 1
        image_file = &#39;pawn-white.png&#39; if color == Color.WHITE else &#39;pawn-black.png&#39;
        super().__init__(color, FigureType.PAWN, image_file, position)

    def set_can_be_captured_en_passant(self, val):
        self.can_be_captured_en_passant = val

    def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
        possible_moves = []
        move_setup = Pawn.MOVE_SETUPS[self.color]

        # pawn at the end - should not happen
        if self.position[0] == move_setup[&#34;last_line&#34;]:
            print(&#39;! Pawn should not be allowed to stay in the end line&#39;)
        else:
            pos = move_setup[&#34;step_forward&#34;](self.position[0], 1), self.position[1]
            figure = figures.get_figure_at(pos)
            if not figure:
                if pos[0] != move_setup[&#34;last_line&#34;]:
                    move = ChessMove(pos, self.position, MoveType.NORMAL)
                else:
                    move = ChessMove(pos, self.position, MoveType.PROMOTION)
                possible_moves.append(move)
                # double move at the beginning
                double_move = move_setup[&#34;step_forward&#34;](self.position[0], 2), self.position[1]
                if self.position[0] == move_setup[&#34;start_line&#34;] and not figures.get_figure_at(double_move):
                    possible_moves.append(ChessMove(double_move, self.position, MoveType.PAWN_DOUBLE_MOVE))
            possible_moves.extend(self.check_captures(figures, threat_for_king))
        return possible_moves

    def check_captures(self, figures: ChessFiguresCollection, threat_for_king=False):
        def move_diagonally(_pos, color):
            move_setup = Pawn.MOVE_SETUPS[self.color]
            opposite_color = Color.BLACK if color == Color.WHITE else Color.WHITE
            if not self.is_move_valid(_pos):
                return None
            figure = figures.get_figure_at(_pos)
            if figure:
                if figure.color == opposite_color or threat_for_king:
                    # if figure.figure_type == FigureType.KING and figure.color == opposite_color:
                    #     print(&#39;! Capture of a king should not be possible&#39;)
                    return MoveType.NORMAL if _pos[0] != move_setup[&#34;last_line&#34;] else MoveType.PROMOTION
            elif threat_for_king:
                return MoveType.NORMAL if _pos[0] != move_setup[&#34;last_line&#34;] else MoveType.PROMOTION
            # capture en passant
            else:
                opponent_pawn_pos = (move_setup[&#34;step_backward&#34;](_pos[0], 1), _pos[1])
                figure = figures.get_figure_at(opponent_pawn_pos)
                if not figure:
                    return None
                if self.position[0] == move_setup[&#34;step_backward&#34;](move_setup[&#34;last_line&#34;], 3) and \
                        figure.figure_type == FigureType.PAWN and \
                        figure.color == opposite_color and \
                        figure.can_be_captured_en_passant:
                    return MoveType.EN_PASSANT
            return None

        def check_capture_on_one_side(pos_height, color):
            move_setup = Pawn.MOVE_SETUPS[self.color]
            _pos = move_setup[&#34;step_forward&#34;](self.position[0], 1), pos_height
            move_type = move_diagonally(_pos, color)
            if move_type:
                if move_type == MoveType.NORMAL or move_type == MoveType.PROMOTION:
                    possible_captures.append(ChessMove(_pos, self.position, move_type))
                elif move_type == MoveType.EN_PASSANT:
                    possible_captures.append(
                        ChessMove(_pos, self.position, move_type,
                                  {&#39;opponent-pawn-pos&#39;: (self.position[0], pos_height)}))

        possible_captures = []
        if self.position[1] &gt; 0:
            check_capture_on_one_side(self.position[1] - 1, self.color)
        if self.position[1] &lt; 7:
            check_capture_on_one_side(self.position[1] + 1, self.color)
        return possible_captures

    @staticmethod
    def clear_en_passant_capture_ability_for_one_team(figures: ChessFiguresCollection, color):
        for figure in figures.figures_list:
            if figure.figure_type == FigureType.PAWN and color == figure.color:
                figure.set_can_be_captured_en_passant(False)


class Knight(Figure):
    def __init__(self, color, position):
        self.value = 3
        image_file = &#39;knight-white.png&#39; if color == Color.WHITE else &#39;knight-black.png&#39;
        super().__init__(color, FigureType.KNIGHT, image_file, position)

    def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
        def wipe_out_bad_moves(move_positions):
            toret = []
            for move_position in move_positions:
                if not self.is_move_valid(move_position):
                    continue
                figure = figures.get_figure_at(move_position)
                if figure and figure.color == self.color:
                    continue
                toret.append(ChessMove(move_position, self.position, MoveType.NORMAL))
            return toret

        possible_moves_positions = [
            (self.position[0] + 2, self.position[1] - 1),
            (self.position[0] + 2, self.position[1] + 1),
            (self.position[0] - 2, self.position[1] + 1),
            (self.position[0] - 2, self.position[1] - 1),
            (self.position[0] + 1, self.position[1] - 2),
            (self.position[0] + 1, self.position[1] + 2),
            (self.position[0] - 1, self.position[1] + 2),
            (self.position[0] - 1, self.position[1] - 2)]
        return wipe_out_bad_moves(possible_moves_positions)


class Bishop(FigureWithLinearMovement):
    def __init__(self, color, position):
        self.value = 3
        self.light_squared = (position[0] + position[1]) % 2 == 1
        image_file = &#39;bishop-white.png&#39; if color == Color.WHITE else &#39;bishop-black.png&#39;
        super().__init__(color, FigureType.BISHOP, image_file, position)

    def check_moves(self, figures, threat_for_king=False):
        directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
        return self.check_moves_linear(figures, directions, threat_for_king)


class Rook(FigureWithLinearMovement):
    def __init__(self, color, position):
        self.value = 5
        self.is_able_to_castle = True
        image_file = &#39;rook-white.png&#39; if color == Color.WHITE else &#39;rook-black.png&#39;
        super().__init__(color, FigureType.ROOK, image_file, position)

    def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
        directions = [(1, 0), (-1, 0), (0, -1), (0, 1)]
        return self.check_moves_linear(figures, directions, threat_for_king)

    def set_is_able_to_castle(self, val):
        self.is_able_to_castle = val


class Queen(FigureWithLinearMovement):
    def __init__(self, color, position):
        self.value = 9
        image_file = &#39;queen-white.png&#39; if color == Color.WHITE else &#39;queen-black.png&#39;
        super().__init__(color, FigureType.QUEEN, image_file, position)

    def check_moves(self, figures, threat_for_king=False):
        directions = [(1, 1), (1, -1), (-1, 1), (-1, -1), (1, 0), (-1, 0), (0, -1), (0, 1)]
        return self.check_moves_linear(figures, directions, threat_for_king)


class King(Figure):
    def __init__(self, color, position):
        self.is_able_to_castle = True
        self.initial_position = (0, 4) if color == Color.WHITE else (7, 4)
        self.check_mask = zeros(shape=(8, 8), dtype=bool)
        self.value = 0
        image_file = &#39;king-white.png&#39; if color == Color.WHITE else &#39;king-black.png&#39;
        super().__init__(color, FigureType.KING, image_file, position)

    def update_check_mask_around_rival_king(self, figures: ChessFiguresCollection):
        opposite_color = Color.WHITE if self.color == Color.BLACK else Color.BLACK
        rival_king_position = figures.get_king_position(opposite_color)
        directions = [(1, 1), (1, -1), (-1, 1), (-1, -1), (1, 0), (-1, 0), (0, -1), (0, 1)]
        for direction in directions:
            position_being_checked = rival_king_position[0] + direction[0], rival_king_position[1] + direction[1]
            if self.is_move_valid(position_being_checked):
                self.check_mask[position_being_checked] = True
        self.check_mask[rival_king_position] = True

    def reset_check_mask(self):
        self.check_mask = zeros(shape=(8, 8), dtype=bool)

    def update_check_mask_by_given_moves(self, moves):
        for move in moves:
            self.check_mask[move.position_to] = True

    # check if at least one of all possible rival&#39;s moves coincide with &#39;position&#39;;
    def update_check_mask(self, figures: ChessFiguresCollection):
        self.reset_check_mask()
        previous_position = self.position
        figures.temporarily_disable(self)

        self.update_check_mask_around_rival_king(figures)

        for figure in figures.figures_list:
            attacked_fields = []
            # only look for checks from the opposite color
            if figure.color == self.color:
                continue
            # pawns have different capture rules
            if figure.figure_type == FigureType.PAWN:
                attacked_fields = figure.check_captures(figures, True)
            # to avoid recursion
            elif figure.figure_type != FigureType.KING:
                attacked_fields = figure.check_moves(figures, True)

            if attacked_fields:
                self.update_check_mask_by_given_moves(attacked_fields)

        figures.restore(self, previous_position)

    def possibility_to_castle(self, figures: ChessFiguresCollection):
        def possibility_to_castle_one_side(move_type):
            if self.position != self.initial_position:
                return

            if move_type == MoveType.CASTLE_SHORT:
                rook_position = (0, 7) if self.color == Color.WHITE else (7, 7)
                offset = -1
            else:
                rook_position = (0, 0) if self.color == Color.WHITE else (7, 0)
                offset = 1
            figure_rook = figures.get_figure_at(rook_position)

            if not figure_rook:
                return
            if figure_rook.figure_type != FigureType.ROOK:
                return
            if not figure_rook.is_able_to_castle:
                return

            figure_offset_1_position = rook_position[0], rook_position[1] + offset
            figure_offset_2_position = rook_position[0], rook_position[1] + 2 * offset
            figure_offset_3_position = rook_position[0], rook_position[1] + 3 * offset

            figure_offset_1 = figures.get_figure_at(figure_offset_1_position)
            figure_offset_2 = figures.get_figure_at(figure_offset_2_position)
            figure_offset_3 = figures.get_figure_at(
                figure_offset_3_position) if move_type == MoveType.CASTLE_LONG else None

            if figure_offset_1:
                return
            if move_type == MoveType.CASTLE_SHORT and self.check_mask[figure_offset_1_position]:
                return
            if figure_offset_2:
                return
            if self.check_mask[figure_offset_2_position]:
                return
            if move_type == MoveType.CASTLE_LONG and (figure_offset_3 or self.check_mask[figure_offset_3_position]):
                return
            final_king_pos = figure_offset_1_position if \
                move_type == MoveType.CASTLE_SHORT else figure_offset_2_position
            final_rook_pos = figure_offset_2_position if \
                move_type == MoveType.CASTLE_SHORT else figure_offset_3_position
            possible_moves.append(ChessMove(final_king_pos, self.position, move_type,
                                            {&#39;rook-end-pos&#39;: final_rook_pos, &#39;rook&#39;: figure_rook}))

        possible_moves = []
        if self.is_able_to_castle:
            possibility_to_castle_one_side(MoveType.CASTLE_SHORT)
            possibility_to_castle_one_side(MoveType.CASTLE_LONG)
        return possible_moves

    def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
        directions = [(1, 1), (1, -1), (-1, 1), (-1, -1), (1, 0), (-1, 0), (0, -1), (0, 1)]
        possible_moves = []
        for direction in directions:
            position_being_checked = self.position[0] + direction[0], self.position[1] + direction[1]
            if not self.is_move_valid(position_being_checked):
                continue
            figure = figures.get_figure_at(position_being_checked)
            if figure:
                if figure.color == self.color:
                    continue
                elif figure.figure_type == FigureType.KING:
                    print(&#39;! Two kings cannot stand next to each other&#39;)
                    continue
            if not self.check_mask[position_being_checked]:
                possible_moves.append(ChessMove(position_being_checked, self.position, MoveType.NORMAL))
        if self.is_able_to_castle and not self.check_mask[self.position]:
            possible_moves.extend(self.possibility_to_castle(figures))
        return possible_moves

    def set_is_able_to_castle(self, val):
        self.is_able_to_castle = val</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.chess.figures.Bishop"><code class="flex name class">
<span>class <span class="ident">Bishop</span></span>
<span>(</span><span>color, position)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bishop(FigureWithLinearMovement):
    def __init__(self, color, position):
        self.value = 3
        self.light_squared = (position[0] + position[1]) % 2 == 1
        image_file = &#39;bishop-white.png&#39; if color == Color.WHITE else &#39;bishop-black.png&#39;
        super().__init__(color, FigureType.BISHOP, image_file, position)

    def check_moves(self, figures, threat_for_king=False):
        directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
        return self.check_moves_linear(figures, directions, threat_for_king)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.chess.figures.FigureWithLinearMovement" href="#src.chess.figures.FigureWithLinearMovement">FigureWithLinearMovement</a></li>
<li><a title="src.chess.figures.Figure" href="#src.chess.figures.Figure">Figure</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.chess.figures.Bishop.check_moves"><code class="name flex">
<span>def <span class="ident">check_moves</span></span>(<span>self, figures, threat_for_king=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_moves(self, figures, threat_for_king=False):
    directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
    return self.check_moves_linear(figures, directions, threat_for_king)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.chess.figures.Figure"><code class="flex name class">
<span>class <span class="ident">Figure</span></span>
<span>(</span><span>color, figure_type, image_file, position)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Figure(ABC):
    def __init__(self, color, figure_type, image_file, position):
        self.color = color
        self.figure_type = figure_type
        self.image_file = image_file
        self.position = position
        super().__init__()

    @abstractmethod
    def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
        pass

    @staticmethod
    def is_move_valid(move_pos):
        return 0 &lt;= move_pos[0] &lt;= 7 and 0 &lt;= move_pos[1] &lt;= 7

    @staticmethod
    def get_figure(figures: ChessFiguresCollection, position):
        return figures.get_figure_at(position)

    @staticmethod
    def remove_figure_on_position(figures: ChessFiguresCollection, position):
        figures.remove_figure_at(position)

    @staticmethod
    def remove_figure(figures: ChessFiguresCollection, figure):
        return figures.remove(figure)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="src.chess.figures.FigureWithLinearMovement" href="#src.chess.figures.FigureWithLinearMovement">FigureWithLinearMovement</a></li>
<li><a title="src.chess.figures.Pawn" href="#src.chess.figures.Pawn">Pawn</a></li>
<li><a title="src.chess.figures.Knight" href="#src.chess.figures.Knight">Knight</a></li>
<li><a title="src.chess.figures.King" href="#src.chess.figures.King">King</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="src.chess.figures.Figure.get_figure"><code class="name flex">
<span>def <span class="ident">get_figure</span></span>(<span>figures, position)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_figure(figures: ChessFiguresCollection, position):
    return figures.get_figure_at(position)</code></pre>
</details>
</dd>
<dt id="src.chess.figures.Figure.is_move_valid"><code class="name flex">
<span>def <span class="ident">is_move_valid</span></span>(<span>move_pos)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_move_valid(move_pos):
    return 0 &lt;= move_pos[0] &lt;= 7 and 0 &lt;= move_pos[1] &lt;= 7</code></pre>
</details>
</dd>
<dt id="src.chess.figures.Figure.remove_figure"><code class="name flex">
<span>def <span class="ident">remove_figure</span></span>(<span>figures, figure)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def remove_figure(figures: ChessFiguresCollection, figure):
    return figures.remove(figure)</code></pre>
</details>
</dd>
<dt id="src.chess.figures.Figure.remove_figure_on_position"><code class="name flex">
<span>def <span class="ident">remove_figure_on_position</span></span>(<span>figures, position)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def remove_figure_on_position(figures: ChessFiguresCollection, position):
    figures.remove_figure_at(position)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.chess.figures.Figure.check_moves"><code class="name flex">
<span>def <span class="ident">check_moves</span></span>(<span>self, figures, threat_for_king=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.chess.figures.FigureWithLinearMovement"><code class="flex name class">
<span>class <span class="ident">FigureWithLinearMovement</span></span>
<span>(</span><span>color, figure_type, image_file, position)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FigureWithLinearMovement(Figure):
    @abstractmethod
    def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
        pass

    def check_moves_linear(self, figures: ChessFiguresCollection, directions, threat_for_king=False):
        possible_moves = []
        pos_x = self.position[0]
        pos_y = self.position[1]
        for direction in directions:
            dir_x = direction[0]
            dir_y = direction[1]
            pos_being_checked = (pos_x + dir_x, pos_y + dir_y)
            while self.is_move_valid(pos_being_checked):
                figure = figures.get_figure_at(pos_being_checked)
                if figure:
                    if figure.color != self.color or threat_for_king:
                        possible_moves.append(ChessMove(pos_being_checked, self.position, MoveType.NORMAL))
                    break
                possible_moves.append(ChessMove(pos_being_checked, self.position, MoveType.NORMAL))
                pos_being_checked = (pos_being_checked[0] + dir_x, pos_being_checked[1] + dir_y)

        return possible_moves</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.chess.figures.Figure" href="#src.chess.figures.Figure">Figure</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="src.chess.figures.Bishop" href="#src.chess.figures.Bishop">Bishop</a></li>
<li><a title="src.chess.figures.Rook" href="#src.chess.figures.Rook">Rook</a></li>
<li><a title="src.chess.figures.Queen" href="#src.chess.figures.Queen">Queen</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.chess.figures.FigureWithLinearMovement.check_moves"><code class="name flex">
<span>def <span class="ident">check_moves</span></span>(<span>self, figures, threat_for_king=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
    pass</code></pre>
</details>
</dd>
<dt id="src.chess.figures.FigureWithLinearMovement.check_moves_linear"><code class="name flex">
<span>def <span class="ident">check_moves_linear</span></span>(<span>self, figures, directions, threat_for_king=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_moves_linear(self, figures: ChessFiguresCollection, directions, threat_for_king=False):
    possible_moves = []
    pos_x = self.position[0]
    pos_y = self.position[1]
    for direction in directions:
        dir_x = direction[0]
        dir_y = direction[1]
        pos_being_checked = (pos_x + dir_x, pos_y + dir_y)
        while self.is_move_valid(pos_being_checked):
            figure = figures.get_figure_at(pos_being_checked)
            if figure:
                if figure.color != self.color or threat_for_king:
                    possible_moves.append(ChessMove(pos_being_checked, self.position, MoveType.NORMAL))
                break
            possible_moves.append(ChessMove(pos_being_checked, self.position, MoveType.NORMAL))
            pos_being_checked = (pos_being_checked[0] + dir_x, pos_being_checked[1] + dir_y)

    return possible_moves</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.chess.figures.King"><code class="flex name class">
<span>class <span class="ident">King</span></span>
<span>(</span><span>color, position)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class King(Figure):
    def __init__(self, color, position):
        self.is_able_to_castle = True
        self.initial_position = (0, 4) if color == Color.WHITE else (7, 4)
        self.check_mask = zeros(shape=(8, 8), dtype=bool)
        self.value = 0
        image_file = &#39;king-white.png&#39; if color == Color.WHITE else &#39;king-black.png&#39;
        super().__init__(color, FigureType.KING, image_file, position)

    def update_check_mask_around_rival_king(self, figures: ChessFiguresCollection):
        opposite_color = Color.WHITE if self.color == Color.BLACK else Color.BLACK
        rival_king_position = figures.get_king_position(opposite_color)
        directions = [(1, 1), (1, -1), (-1, 1), (-1, -1), (1, 0), (-1, 0), (0, -1), (0, 1)]
        for direction in directions:
            position_being_checked = rival_king_position[0] + direction[0], rival_king_position[1] + direction[1]
            if self.is_move_valid(position_being_checked):
                self.check_mask[position_being_checked] = True
        self.check_mask[rival_king_position] = True

    def reset_check_mask(self):
        self.check_mask = zeros(shape=(8, 8), dtype=bool)

    def update_check_mask_by_given_moves(self, moves):
        for move in moves:
            self.check_mask[move.position_to] = True

    # check if at least one of all possible rival&#39;s moves coincide with &#39;position&#39;;
    def update_check_mask(self, figures: ChessFiguresCollection):
        self.reset_check_mask()
        previous_position = self.position
        figures.temporarily_disable(self)

        self.update_check_mask_around_rival_king(figures)

        for figure in figures.figures_list:
            attacked_fields = []
            # only look for checks from the opposite color
            if figure.color == self.color:
                continue
            # pawns have different capture rules
            if figure.figure_type == FigureType.PAWN:
                attacked_fields = figure.check_captures(figures, True)
            # to avoid recursion
            elif figure.figure_type != FigureType.KING:
                attacked_fields = figure.check_moves(figures, True)

            if attacked_fields:
                self.update_check_mask_by_given_moves(attacked_fields)

        figures.restore(self, previous_position)

    def possibility_to_castle(self, figures: ChessFiguresCollection):
        def possibility_to_castle_one_side(move_type):
            if self.position != self.initial_position:
                return

            if move_type == MoveType.CASTLE_SHORT:
                rook_position = (0, 7) if self.color == Color.WHITE else (7, 7)
                offset = -1
            else:
                rook_position = (0, 0) if self.color == Color.WHITE else (7, 0)
                offset = 1
            figure_rook = figures.get_figure_at(rook_position)

            if not figure_rook:
                return
            if figure_rook.figure_type != FigureType.ROOK:
                return
            if not figure_rook.is_able_to_castle:
                return

            figure_offset_1_position = rook_position[0], rook_position[1] + offset
            figure_offset_2_position = rook_position[0], rook_position[1] + 2 * offset
            figure_offset_3_position = rook_position[0], rook_position[1] + 3 * offset

            figure_offset_1 = figures.get_figure_at(figure_offset_1_position)
            figure_offset_2 = figures.get_figure_at(figure_offset_2_position)
            figure_offset_3 = figures.get_figure_at(
                figure_offset_3_position) if move_type == MoveType.CASTLE_LONG else None

            if figure_offset_1:
                return
            if move_type == MoveType.CASTLE_SHORT and self.check_mask[figure_offset_1_position]:
                return
            if figure_offset_2:
                return
            if self.check_mask[figure_offset_2_position]:
                return
            if move_type == MoveType.CASTLE_LONG and (figure_offset_3 or self.check_mask[figure_offset_3_position]):
                return
            final_king_pos = figure_offset_1_position if \
                move_type == MoveType.CASTLE_SHORT else figure_offset_2_position
            final_rook_pos = figure_offset_2_position if \
                move_type == MoveType.CASTLE_SHORT else figure_offset_3_position
            possible_moves.append(ChessMove(final_king_pos, self.position, move_type,
                                            {&#39;rook-end-pos&#39;: final_rook_pos, &#39;rook&#39;: figure_rook}))

        possible_moves = []
        if self.is_able_to_castle:
            possibility_to_castle_one_side(MoveType.CASTLE_SHORT)
            possibility_to_castle_one_side(MoveType.CASTLE_LONG)
        return possible_moves

    def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
        directions = [(1, 1), (1, -1), (-1, 1), (-1, -1), (1, 0), (-1, 0), (0, -1), (0, 1)]
        possible_moves = []
        for direction in directions:
            position_being_checked = self.position[0] + direction[0], self.position[1] + direction[1]
            if not self.is_move_valid(position_being_checked):
                continue
            figure = figures.get_figure_at(position_being_checked)
            if figure:
                if figure.color == self.color:
                    continue
                elif figure.figure_type == FigureType.KING:
                    print(&#39;! Two kings cannot stand next to each other&#39;)
                    continue
            if not self.check_mask[position_being_checked]:
                possible_moves.append(ChessMove(position_being_checked, self.position, MoveType.NORMAL))
        if self.is_able_to_castle and not self.check_mask[self.position]:
            possible_moves.extend(self.possibility_to_castle(figures))
        return possible_moves

    def set_is_able_to_castle(self, val):
        self.is_able_to_castle = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.chess.figures.Figure" href="#src.chess.figures.Figure">Figure</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.chess.figures.King.check_moves"><code class="name flex">
<span>def <span class="ident">check_moves</span></span>(<span>self, figures, threat_for_king=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
    directions = [(1, 1), (1, -1), (-1, 1), (-1, -1), (1, 0), (-1, 0), (0, -1), (0, 1)]
    possible_moves = []
    for direction in directions:
        position_being_checked = self.position[0] + direction[0], self.position[1] + direction[1]
        if not self.is_move_valid(position_being_checked):
            continue
        figure = figures.get_figure_at(position_being_checked)
        if figure:
            if figure.color == self.color:
                continue
            elif figure.figure_type == FigureType.KING:
                print(&#39;! Two kings cannot stand next to each other&#39;)
                continue
        if not self.check_mask[position_being_checked]:
            possible_moves.append(ChessMove(position_being_checked, self.position, MoveType.NORMAL))
    if self.is_able_to_castle and not self.check_mask[self.position]:
        possible_moves.extend(self.possibility_to_castle(figures))
    return possible_moves</code></pre>
</details>
</dd>
<dt id="src.chess.figures.King.possibility_to_castle"><code class="name flex">
<span>def <span class="ident">possibility_to_castle</span></span>(<span>self, figures)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def possibility_to_castle(self, figures: ChessFiguresCollection):
    def possibility_to_castle_one_side(move_type):
        if self.position != self.initial_position:
            return

        if move_type == MoveType.CASTLE_SHORT:
            rook_position = (0, 7) if self.color == Color.WHITE else (7, 7)
            offset = -1
        else:
            rook_position = (0, 0) if self.color == Color.WHITE else (7, 0)
            offset = 1
        figure_rook = figures.get_figure_at(rook_position)

        if not figure_rook:
            return
        if figure_rook.figure_type != FigureType.ROOK:
            return
        if not figure_rook.is_able_to_castle:
            return

        figure_offset_1_position = rook_position[0], rook_position[1] + offset
        figure_offset_2_position = rook_position[0], rook_position[1] + 2 * offset
        figure_offset_3_position = rook_position[0], rook_position[1] + 3 * offset

        figure_offset_1 = figures.get_figure_at(figure_offset_1_position)
        figure_offset_2 = figures.get_figure_at(figure_offset_2_position)
        figure_offset_3 = figures.get_figure_at(
            figure_offset_3_position) if move_type == MoveType.CASTLE_LONG else None

        if figure_offset_1:
            return
        if move_type == MoveType.CASTLE_SHORT and self.check_mask[figure_offset_1_position]:
            return
        if figure_offset_2:
            return
        if self.check_mask[figure_offset_2_position]:
            return
        if move_type == MoveType.CASTLE_LONG and (figure_offset_3 or self.check_mask[figure_offset_3_position]):
            return
        final_king_pos = figure_offset_1_position if \
            move_type == MoveType.CASTLE_SHORT else figure_offset_2_position
        final_rook_pos = figure_offset_2_position if \
            move_type == MoveType.CASTLE_SHORT else figure_offset_3_position
        possible_moves.append(ChessMove(final_king_pos, self.position, move_type,
                                        {&#39;rook-end-pos&#39;: final_rook_pos, &#39;rook&#39;: figure_rook}))

    possible_moves = []
    if self.is_able_to_castle:
        possibility_to_castle_one_side(MoveType.CASTLE_SHORT)
        possibility_to_castle_one_side(MoveType.CASTLE_LONG)
    return possible_moves</code></pre>
</details>
</dd>
<dt id="src.chess.figures.King.reset_check_mask"><code class="name flex">
<span>def <span class="ident">reset_check_mask</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_check_mask(self):
    self.check_mask = zeros(shape=(8, 8), dtype=bool)</code></pre>
</details>
</dd>
<dt id="src.chess.figures.King.set_is_able_to_castle"><code class="name flex">
<span>def <span class="ident">set_is_able_to_castle</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_is_able_to_castle(self, val):
    self.is_able_to_castle = val</code></pre>
</details>
</dd>
<dt id="src.chess.figures.King.update_check_mask"><code class="name flex">
<span>def <span class="ident">update_check_mask</span></span>(<span>self, figures)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_check_mask(self, figures: ChessFiguresCollection):
    self.reset_check_mask()
    previous_position = self.position
    figures.temporarily_disable(self)

    self.update_check_mask_around_rival_king(figures)

    for figure in figures.figures_list:
        attacked_fields = []
        # only look for checks from the opposite color
        if figure.color == self.color:
            continue
        # pawns have different capture rules
        if figure.figure_type == FigureType.PAWN:
            attacked_fields = figure.check_captures(figures, True)
        # to avoid recursion
        elif figure.figure_type != FigureType.KING:
            attacked_fields = figure.check_moves(figures, True)

        if attacked_fields:
            self.update_check_mask_by_given_moves(attacked_fields)

    figures.restore(self, previous_position)</code></pre>
</details>
</dd>
<dt id="src.chess.figures.King.update_check_mask_around_rival_king"><code class="name flex">
<span>def <span class="ident">update_check_mask_around_rival_king</span></span>(<span>self, figures)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_check_mask_around_rival_king(self, figures: ChessFiguresCollection):
    opposite_color = Color.WHITE if self.color == Color.BLACK else Color.BLACK
    rival_king_position = figures.get_king_position(opposite_color)
    directions = [(1, 1), (1, -1), (-1, 1), (-1, -1), (1, 0), (-1, 0), (0, -1), (0, 1)]
    for direction in directions:
        position_being_checked = rival_king_position[0] + direction[0], rival_king_position[1] + direction[1]
        if self.is_move_valid(position_being_checked):
            self.check_mask[position_being_checked] = True
    self.check_mask[rival_king_position] = True</code></pre>
</details>
</dd>
<dt id="src.chess.figures.King.update_check_mask_by_given_moves"><code class="name flex">
<span>def <span class="ident">update_check_mask_by_given_moves</span></span>(<span>self, moves)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_check_mask_by_given_moves(self, moves):
    for move in moves:
        self.check_mask[move.position_to] = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.chess.figures.Knight"><code class="flex name class">
<span>class <span class="ident">Knight</span></span>
<span>(</span><span>color, position)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Knight(Figure):
    def __init__(self, color, position):
        self.value = 3
        image_file = &#39;knight-white.png&#39; if color == Color.WHITE else &#39;knight-black.png&#39;
        super().__init__(color, FigureType.KNIGHT, image_file, position)

    def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
        def wipe_out_bad_moves(move_positions):
            toret = []
            for move_position in move_positions:
                if not self.is_move_valid(move_position):
                    continue
                figure = figures.get_figure_at(move_position)
                if figure and figure.color == self.color:
                    continue
                toret.append(ChessMove(move_position, self.position, MoveType.NORMAL))
            return toret

        possible_moves_positions = [
            (self.position[0] + 2, self.position[1] - 1),
            (self.position[0] + 2, self.position[1] + 1),
            (self.position[0] - 2, self.position[1] + 1),
            (self.position[0] - 2, self.position[1] - 1),
            (self.position[0] + 1, self.position[1] - 2),
            (self.position[0] + 1, self.position[1] + 2),
            (self.position[0] - 1, self.position[1] + 2),
            (self.position[0] - 1, self.position[1] - 2)]
        return wipe_out_bad_moves(possible_moves_positions)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.chess.figures.Figure" href="#src.chess.figures.Figure">Figure</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.chess.figures.Knight.check_moves"><code class="name flex">
<span>def <span class="ident">check_moves</span></span>(<span>self, figures, threat_for_king=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
    def wipe_out_bad_moves(move_positions):
        toret = []
        for move_position in move_positions:
            if not self.is_move_valid(move_position):
                continue
            figure = figures.get_figure_at(move_position)
            if figure and figure.color == self.color:
                continue
            toret.append(ChessMove(move_position, self.position, MoveType.NORMAL))
        return toret

    possible_moves_positions = [
        (self.position[0] + 2, self.position[1] - 1),
        (self.position[0] + 2, self.position[1] + 1),
        (self.position[0] - 2, self.position[1] + 1),
        (self.position[0] - 2, self.position[1] - 1),
        (self.position[0] + 1, self.position[1] - 2),
        (self.position[0] + 1, self.position[1] + 2),
        (self.position[0] - 1, self.position[1] + 2),
        (self.position[0] - 1, self.position[1] - 2)]
    return wipe_out_bad_moves(possible_moves_positions)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.chess.figures.Pawn"><code class="flex name class">
<span>class <span class="ident">Pawn</span></span>
<span>(</span><span>color, position)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pawn(Figure):
    MOVE_SETUPS = {
        Color.WHITE: {
            &#34;start_line&#34;: 1,
            &#34;last_line&#34;: 7,
            &#34;step_forward&#34;: lambda x, step: x + step,
            &#34;step_backward&#34;: lambda x, step: x - step
        },
        Color.BLACK: {
            &#34;start_line&#34;: 6,
            &#34;last_line&#34;: 0,
            &#34;step_forward&#34;: lambda x, step: x - step,
            &#34;step_backward&#34;: lambda x, step: x + step
        }
    }

    def __init__(self, color, position):
        self.can_be_captured_en_passant = False
        self.value = 1
        image_file = &#39;pawn-white.png&#39; if color == Color.WHITE else &#39;pawn-black.png&#39;
        super().__init__(color, FigureType.PAWN, image_file, position)

    def set_can_be_captured_en_passant(self, val):
        self.can_be_captured_en_passant = val

    def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
        possible_moves = []
        move_setup = Pawn.MOVE_SETUPS[self.color]

        # pawn at the end - should not happen
        if self.position[0] == move_setup[&#34;last_line&#34;]:
            print(&#39;! Pawn should not be allowed to stay in the end line&#39;)
        else:
            pos = move_setup[&#34;step_forward&#34;](self.position[0], 1), self.position[1]
            figure = figures.get_figure_at(pos)
            if not figure:
                if pos[0] != move_setup[&#34;last_line&#34;]:
                    move = ChessMove(pos, self.position, MoveType.NORMAL)
                else:
                    move = ChessMove(pos, self.position, MoveType.PROMOTION)
                possible_moves.append(move)
                # double move at the beginning
                double_move = move_setup[&#34;step_forward&#34;](self.position[0], 2), self.position[1]
                if self.position[0] == move_setup[&#34;start_line&#34;] and not figures.get_figure_at(double_move):
                    possible_moves.append(ChessMove(double_move, self.position, MoveType.PAWN_DOUBLE_MOVE))
            possible_moves.extend(self.check_captures(figures, threat_for_king))
        return possible_moves

    def check_captures(self, figures: ChessFiguresCollection, threat_for_king=False):
        def move_diagonally(_pos, color):
            move_setup = Pawn.MOVE_SETUPS[self.color]
            opposite_color = Color.BLACK if color == Color.WHITE else Color.WHITE
            if not self.is_move_valid(_pos):
                return None
            figure = figures.get_figure_at(_pos)
            if figure:
                if figure.color == opposite_color or threat_for_king:
                    # if figure.figure_type == FigureType.KING and figure.color == opposite_color:
                    #     print(&#39;! Capture of a king should not be possible&#39;)
                    return MoveType.NORMAL if _pos[0] != move_setup[&#34;last_line&#34;] else MoveType.PROMOTION
            elif threat_for_king:
                return MoveType.NORMAL if _pos[0] != move_setup[&#34;last_line&#34;] else MoveType.PROMOTION
            # capture en passant
            else:
                opponent_pawn_pos = (move_setup[&#34;step_backward&#34;](_pos[0], 1), _pos[1])
                figure = figures.get_figure_at(opponent_pawn_pos)
                if not figure:
                    return None
                if self.position[0] == move_setup[&#34;step_backward&#34;](move_setup[&#34;last_line&#34;], 3) and \
                        figure.figure_type == FigureType.PAWN and \
                        figure.color == opposite_color and \
                        figure.can_be_captured_en_passant:
                    return MoveType.EN_PASSANT
            return None

        def check_capture_on_one_side(pos_height, color):
            move_setup = Pawn.MOVE_SETUPS[self.color]
            _pos = move_setup[&#34;step_forward&#34;](self.position[0], 1), pos_height
            move_type = move_diagonally(_pos, color)
            if move_type:
                if move_type == MoveType.NORMAL or move_type == MoveType.PROMOTION:
                    possible_captures.append(ChessMove(_pos, self.position, move_type))
                elif move_type == MoveType.EN_PASSANT:
                    possible_captures.append(
                        ChessMove(_pos, self.position, move_type,
                                  {&#39;opponent-pawn-pos&#39;: (self.position[0], pos_height)}))

        possible_captures = []
        if self.position[1] &gt; 0:
            check_capture_on_one_side(self.position[1] - 1, self.color)
        if self.position[1] &lt; 7:
            check_capture_on_one_side(self.position[1] + 1, self.color)
        return possible_captures

    @staticmethod
    def clear_en_passant_capture_ability_for_one_team(figures: ChessFiguresCollection, color):
        for figure in figures.figures_list:
            if figure.figure_type == FigureType.PAWN and color == figure.color:
                figure.set_can_be_captured_en_passant(False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.chess.figures.Figure" href="#src.chess.figures.Figure">Figure</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="src.chess.figures.Pawn.MOVE_SETUPS"><code class="name">var <span class="ident">MOVE_SETUPS</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="src.chess.figures.Pawn.clear_en_passant_capture_ability_for_one_team"><code class="name flex">
<span>def <span class="ident">clear_en_passant_capture_ability_for_one_team</span></span>(<span>figures, color)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def clear_en_passant_capture_ability_for_one_team(figures: ChessFiguresCollection, color):
    for figure in figures.figures_list:
        if figure.figure_type == FigureType.PAWN and color == figure.color:
            figure.set_can_be_captured_en_passant(False)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.chess.figures.Pawn.check_captures"><code class="name flex">
<span>def <span class="ident">check_captures</span></span>(<span>self, figures, threat_for_king=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_captures(self, figures: ChessFiguresCollection, threat_for_king=False):
    def move_diagonally(_pos, color):
        move_setup = Pawn.MOVE_SETUPS[self.color]
        opposite_color = Color.BLACK if color == Color.WHITE else Color.WHITE
        if not self.is_move_valid(_pos):
            return None
        figure = figures.get_figure_at(_pos)
        if figure:
            if figure.color == opposite_color or threat_for_king:
                # if figure.figure_type == FigureType.KING and figure.color == opposite_color:
                #     print(&#39;! Capture of a king should not be possible&#39;)
                return MoveType.NORMAL if _pos[0] != move_setup[&#34;last_line&#34;] else MoveType.PROMOTION
        elif threat_for_king:
            return MoveType.NORMAL if _pos[0] != move_setup[&#34;last_line&#34;] else MoveType.PROMOTION
        # capture en passant
        else:
            opponent_pawn_pos = (move_setup[&#34;step_backward&#34;](_pos[0], 1), _pos[1])
            figure = figures.get_figure_at(opponent_pawn_pos)
            if not figure:
                return None
            if self.position[0] == move_setup[&#34;step_backward&#34;](move_setup[&#34;last_line&#34;], 3) and \
                    figure.figure_type == FigureType.PAWN and \
                    figure.color == opposite_color and \
                    figure.can_be_captured_en_passant:
                return MoveType.EN_PASSANT
        return None

    def check_capture_on_one_side(pos_height, color):
        move_setup = Pawn.MOVE_SETUPS[self.color]
        _pos = move_setup[&#34;step_forward&#34;](self.position[0], 1), pos_height
        move_type = move_diagonally(_pos, color)
        if move_type:
            if move_type == MoveType.NORMAL or move_type == MoveType.PROMOTION:
                possible_captures.append(ChessMove(_pos, self.position, move_type))
            elif move_type == MoveType.EN_PASSANT:
                possible_captures.append(
                    ChessMove(_pos, self.position, move_type,
                              {&#39;opponent-pawn-pos&#39;: (self.position[0], pos_height)}))

    possible_captures = []
    if self.position[1] &gt; 0:
        check_capture_on_one_side(self.position[1] - 1, self.color)
    if self.position[1] &lt; 7:
        check_capture_on_one_side(self.position[1] + 1, self.color)
    return possible_captures</code></pre>
</details>
</dd>
<dt id="src.chess.figures.Pawn.check_moves"><code class="name flex">
<span>def <span class="ident">check_moves</span></span>(<span>self, figures, threat_for_king=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
    possible_moves = []
    move_setup = Pawn.MOVE_SETUPS[self.color]

    # pawn at the end - should not happen
    if self.position[0] == move_setup[&#34;last_line&#34;]:
        print(&#39;! Pawn should not be allowed to stay in the end line&#39;)
    else:
        pos = move_setup[&#34;step_forward&#34;](self.position[0], 1), self.position[1]
        figure = figures.get_figure_at(pos)
        if not figure:
            if pos[0] != move_setup[&#34;last_line&#34;]:
                move = ChessMove(pos, self.position, MoveType.NORMAL)
            else:
                move = ChessMove(pos, self.position, MoveType.PROMOTION)
            possible_moves.append(move)
            # double move at the beginning
            double_move = move_setup[&#34;step_forward&#34;](self.position[0], 2), self.position[1]
            if self.position[0] == move_setup[&#34;start_line&#34;] and not figures.get_figure_at(double_move):
                possible_moves.append(ChessMove(double_move, self.position, MoveType.PAWN_DOUBLE_MOVE))
        possible_moves.extend(self.check_captures(figures, threat_for_king))
    return possible_moves</code></pre>
</details>
</dd>
<dt id="src.chess.figures.Pawn.set_can_be_captured_en_passant"><code class="name flex">
<span>def <span class="ident">set_can_be_captured_en_passant</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_can_be_captured_en_passant(self, val):
    self.can_be_captured_en_passant = val</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.chess.figures.Queen"><code class="flex name class">
<span>class <span class="ident">Queen</span></span>
<span>(</span><span>color, position)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Queen(FigureWithLinearMovement):
    def __init__(self, color, position):
        self.value = 9
        image_file = &#39;queen-white.png&#39; if color == Color.WHITE else &#39;queen-black.png&#39;
        super().__init__(color, FigureType.QUEEN, image_file, position)

    def check_moves(self, figures, threat_for_king=False):
        directions = [(1, 1), (1, -1), (-1, 1), (-1, -1), (1, 0), (-1, 0), (0, -1), (0, 1)]
        return self.check_moves_linear(figures, directions, threat_for_king)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.chess.figures.FigureWithLinearMovement" href="#src.chess.figures.FigureWithLinearMovement">FigureWithLinearMovement</a></li>
<li><a title="src.chess.figures.Figure" href="#src.chess.figures.Figure">Figure</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.chess.figures.Queen.check_moves"><code class="name flex">
<span>def <span class="ident">check_moves</span></span>(<span>self, figures, threat_for_king=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_moves(self, figures, threat_for_king=False):
    directions = [(1, 1), (1, -1), (-1, 1), (-1, -1), (1, 0), (-1, 0), (0, -1), (0, 1)]
    return self.check_moves_linear(figures, directions, threat_for_king)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.chess.figures.Rook"><code class="flex name class">
<span>class <span class="ident">Rook</span></span>
<span>(</span><span>color, position)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rook(FigureWithLinearMovement):
    def __init__(self, color, position):
        self.value = 5
        self.is_able_to_castle = True
        image_file = &#39;rook-white.png&#39; if color == Color.WHITE else &#39;rook-black.png&#39;
        super().__init__(color, FigureType.ROOK, image_file, position)

    def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
        directions = [(1, 0), (-1, 0), (0, -1), (0, 1)]
        return self.check_moves_linear(figures, directions, threat_for_king)

    def set_is_able_to_castle(self, val):
        self.is_able_to_castle = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.chess.figures.FigureWithLinearMovement" href="#src.chess.figures.FigureWithLinearMovement">FigureWithLinearMovement</a></li>
<li><a title="src.chess.figures.Figure" href="#src.chess.figures.Figure">Figure</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.chess.figures.Rook.check_moves"><code class="name flex">
<span>def <span class="ident">check_moves</span></span>(<span>self, figures, threat_for_king=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_moves(self, figures: ChessFiguresCollection, threat_for_king=False):
    directions = [(1, 0), (-1, 0), (0, -1), (0, 1)]
    return self.check_moves_linear(figures, directions, threat_for_king)</code></pre>
</details>
</dd>
<dt id="src.chess.figures.Rook.set_is_able_to_castle"><code class="name flex">
<span>def <span class="ident">set_is_able_to_castle</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_is_able_to_castle(self, val):
    self.is_able_to_castle = val</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.chess" href="index.html">src.chess</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.chess.figures.Bishop" href="#src.chess.figures.Bishop">Bishop</a></code></h4>
<ul class="">
<li><code><a title="src.chess.figures.Bishop.check_moves" href="#src.chess.figures.Bishop.check_moves">check_moves</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.chess.figures.Figure" href="#src.chess.figures.Figure">Figure</a></code></h4>
<ul class="">
<li><code><a title="src.chess.figures.Figure.check_moves" href="#src.chess.figures.Figure.check_moves">check_moves</a></code></li>
<li><code><a title="src.chess.figures.Figure.get_figure" href="#src.chess.figures.Figure.get_figure">get_figure</a></code></li>
<li><code><a title="src.chess.figures.Figure.is_move_valid" href="#src.chess.figures.Figure.is_move_valid">is_move_valid</a></code></li>
<li><code><a title="src.chess.figures.Figure.remove_figure" href="#src.chess.figures.Figure.remove_figure">remove_figure</a></code></li>
<li><code><a title="src.chess.figures.Figure.remove_figure_on_position" href="#src.chess.figures.Figure.remove_figure_on_position">remove_figure_on_position</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.chess.figures.FigureWithLinearMovement" href="#src.chess.figures.FigureWithLinearMovement">FigureWithLinearMovement</a></code></h4>
<ul class="">
<li><code><a title="src.chess.figures.FigureWithLinearMovement.check_moves" href="#src.chess.figures.FigureWithLinearMovement.check_moves">check_moves</a></code></li>
<li><code><a title="src.chess.figures.FigureWithLinearMovement.check_moves_linear" href="#src.chess.figures.FigureWithLinearMovement.check_moves_linear">check_moves_linear</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.chess.figures.King" href="#src.chess.figures.King">King</a></code></h4>
<ul class="">
<li><code><a title="src.chess.figures.King.check_moves" href="#src.chess.figures.King.check_moves">check_moves</a></code></li>
<li><code><a title="src.chess.figures.King.possibility_to_castle" href="#src.chess.figures.King.possibility_to_castle">possibility_to_castle</a></code></li>
<li><code><a title="src.chess.figures.King.reset_check_mask" href="#src.chess.figures.King.reset_check_mask">reset_check_mask</a></code></li>
<li><code><a title="src.chess.figures.King.set_is_able_to_castle" href="#src.chess.figures.King.set_is_able_to_castle">set_is_able_to_castle</a></code></li>
<li><code><a title="src.chess.figures.King.update_check_mask" href="#src.chess.figures.King.update_check_mask">update_check_mask</a></code></li>
<li><code><a title="src.chess.figures.King.update_check_mask_around_rival_king" href="#src.chess.figures.King.update_check_mask_around_rival_king">update_check_mask_around_rival_king</a></code></li>
<li><code><a title="src.chess.figures.King.update_check_mask_by_given_moves" href="#src.chess.figures.King.update_check_mask_by_given_moves">update_check_mask_by_given_moves</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.chess.figures.Knight" href="#src.chess.figures.Knight">Knight</a></code></h4>
<ul class="">
<li><code><a title="src.chess.figures.Knight.check_moves" href="#src.chess.figures.Knight.check_moves">check_moves</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.chess.figures.Pawn" href="#src.chess.figures.Pawn">Pawn</a></code></h4>
<ul class="">
<li><code><a title="src.chess.figures.Pawn.MOVE_SETUPS" href="#src.chess.figures.Pawn.MOVE_SETUPS">MOVE_SETUPS</a></code></li>
<li><code><a title="src.chess.figures.Pawn.check_captures" href="#src.chess.figures.Pawn.check_captures">check_captures</a></code></li>
<li><code><a title="src.chess.figures.Pawn.check_moves" href="#src.chess.figures.Pawn.check_moves">check_moves</a></code></li>
<li><code><a title="src.chess.figures.Pawn.clear_en_passant_capture_ability_for_one_team" href="#src.chess.figures.Pawn.clear_en_passant_capture_ability_for_one_team">clear_en_passant_capture_ability_for_one_team</a></code></li>
<li><code><a title="src.chess.figures.Pawn.set_can_be_captured_en_passant" href="#src.chess.figures.Pawn.set_can_be_captured_en_passant">set_can_be_captured_en_passant</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.chess.figures.Queen" href="#src.chess.figures.Queen">Queen</a></code></h4>
<ul class="">
<li><code><a title="src.chess.figures.Queen.check_moves" href="#src.chess.figures.Queen.check_moves">check_moves</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.chess.figures.Rook" href="#src.chess.figures.Rook">Rook</a></code></h4>
<ul class="">
<li><code><a title="src.chess.figures.Rook.check_moves" href="#src.chess.figures.Rook.check_moves">check_moves</a></code></li>
<li><code><a title="src.chess.figures.Rook.set_is_able_to_castle" href="#src.chess.figures.Rook.set_is_able_to_castle">set_is_able_to_castle</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>