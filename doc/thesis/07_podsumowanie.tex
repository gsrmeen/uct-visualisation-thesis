\documentclass[uct_visualisation_thesis.tex]{subfiles}

\section{Weryfikacja rezultatów}
\subsection{Uzyskane efekty}
Dostarczany produkt jest sprawnie działającym i wygodnym narzędziem do wizualizowania i analizowania drzew stanów algorytmu UCT. Pozwala on również na ich generowanie podczas rozgrywki przeciwko komputerowi w jedną z dwóch zaimplementowanych gier logicznych. Dodatkowo, wszystkie opisywanie wcześniej funkcjonalności spaja intuicyjny i uporządkowany interfejs graficzny.


\subsection{Testy akceptacyjne}
Testy akceptacyjne zostały przeprowadzone w celu sprawdzenia, czy aplikacja spełnia założenia opisane w dokumentacji wymagań projektu. Test pierwszy konfrontuje założenia modułu \textit{Gry}, test drugi – modułu \textit{Serializacja}, a pozostałe testy weryfikują założenia modułu \textit{Wizualizacja}.\\

Testy akceptacyjne zostały wykonane na komputerze:

\begin{itemize}
	\item z zainstalowanym systemem operacyjnym \textit{Windows 10 Education N},
	\item z zainstalowanym interpreterem języka \textit{Python 3.7.2} i biblioteką \textit{PyQt5},
	\item wyposażonym w procesor \textit{Intel Core i7-8700k @3.70 GHz},
	\item wyposażonym w kartę graficzną \textit{NVIDIA GeForce GTX 1060 6GB},
	\item wyposażonym w 32GB pamięci RAM.
\end{itemize}

Poniżej przedstawiony jest opis pięciu testów wraz z uzyskanymi wynikami.

\begin{enumerate}
	\item 
	\begin{itemize}
		\item \textbf{Testowany moduł}: \textit{Gra}
		\item \textbf{Testowane wymaganie}: Użytkownik będzie mógł wybrać jedną z dwóch przykładowych gier, a do wyboru będzie miał trzy tryby rozgrywki.
		\item \textbf{Kroki testowe}:
		\begin{itemize} 
			\item Z menu głównego aplikacji wybierz opcję \textit{Chess}. 
			\item Z menu głównego aplikacji wybierz opcję \textit{Player vs Player} i sprawdź tryb rozgrywki dla dwóch graczy. 
			\item Z menu głównego aplikacji wybierz opcję \textit{Player vs PC} dla różnych ustawień algorytmu UCT. 
			\item Z menu głównego aplikacji wybierz opcję \textit{PC vs PC} dla różnych ustawień algorytmu UCT. 
			\item Z menu głównego aplikacji wybierz \textit{Mancala} i powtórz kroki 2–5.
		\end{itemize}
		\item \textbf{Wynik}: Pozytywny.\\
	\end{itemize}
	\item 
	\begin{itemize}
		\item \textbf{Testowany moduł}: \textit{Serializacja}
		\item \textbf{Testowane wymaganie}: Użytkownik będzie mógł zapisać analizowane drzewa do pliku csv, do pliku binarnego oraz do bitmapy.
		\item \textbf{Kroki testowe}:
		\begin{itemize} 
			\item Z menu głównego aplikacji wybierz ścieżkę do dowolnego pliku z zserializowanym drzewem. 
			\item Naciśnij przycisk \textit{Inspect tree}. \item Naciśnij przycisk \textit{Save to csv file}. 
			\item Naciśnij przycisk \textit{Save to binary file}. 
			\item Naciśnij przycisk \textit{Save to bitmap file}. 
			\item Sprawdź, czy bitmapa wygenerowana w kroku 5 odpowiada drzewu z pliku początkowego. 
			\item Z menu głównego aplikacji wybierz ścieżkę plików wygenerowanych w kroku 3 i 4, żeby sprawdzić, czy zapisane drzewa wizualizowane są tak samo jak w początkowym pliku.
		\end{itemize}
		\item \textbf{Wynik}: Pozytywny.\\
	\end{itemize}
	\item
	\begin{itemize}
		\item \textbf{Testowany moduł}: \textit{Wizualizacja}
		\item \textbf{Testowane wymaganie}: Użytkownik będzie mógł wyświetlić informacje związane z wybranym węzłem drzewa, a także przybliżać i oddalać cały graf.
		\item \textbf{Kroki testowe}:
		\begin{itemize} 
			\item Z menu głównego aplikacji wybierz ścieżkę do dowolnego pliku z drzewem. 
			\item Naciśnij przycisk \textit{Inspect tree}. 
			\item Przy użyciu prawego przycisku myszy chwyć za obszar rysowania i poruszaj się po wizualizacji.
			\item Używając środkowego przycisku myszy, przybliż i oddal wizualizowane drzewo. 
			\item Kliknij dowolny wierzchołek drzewa lewym przyciskiem myszy i sprawdź, czy panel z prawej strony wyświetla informacje związane z wybranym wierzchołkiem.
		\end{itemize}
		\item \textbf{Wynik}: Pozytywny.\\
	\end{itemize}
	\item
	\begin{itemize}
		\item \textbf{Testowany moduł}: \textit{Wizualizacja}
		\item \textbf{Testowane wymaganie}: Dla drzew do $100 000$ wierzchołków wizualizacja nie powinna zajmować więcej niż $3$s.
		\item \textbf{Kroki testowe}:
		\begin{itemize} 
			\item Z menu głównego aplikacji wybierz ścieżkę do pliku \textit{tree\textunderscore 100k.csv}. 
			\item Naciśnij przycisk \textit{Inspect trees}.
		\end{itemize}
		\item \textbf{Wynik}: Pozytywny -- deserializacja, ulepszony algorytm Walkera i wyświetlenie drzewa z pliku zajęło 2.802s.\\
	\end{itemize}
	\item 
	\begin{itemize}
		\item \textbf{Testowany moduł}: \textit{Wizualizacja}
		\item \textbf{Testowane wymaganie}: Dla drzew do $250 000$ wierzchołków wizualizacja nie powinna zajmować więcej niż $5$s.
		\item \textbf{Kroki testowe}:
		\begin{itemize} 
			\item Z menu głównego aplikacji wybierz ścieżkę do pliku \textit{tree\textunderscore 250k.csv}.
			\item Naciśnij przycisk \textit{Inspect tree}.
		\end{itemize}
		\item \textbf{Wynik}: Pozytywny -- deserializacja, ulepszony algorytm Walkera i wyświetlenie drzewa z pliku zajęło 4.626s.\\
	\end{itemize}
\end{enumerate}

Wszystkie testy akceptacyjne zakończyły się pozytywnie, a więc wymagania zostały spełnione.

\section{Dalszy rozwój}
\subsection{Kontynuacja pracy}
Aplikacja spełnia wszystkie początkowe wymagania określone w rozdziale \ref{sec:establishments}, jednak w przyszłości mogą zostać do niej dodane usprawnienia. W celu dalszej poprawy jakości i zwiększenia liczby możliwych opcji, obecny produkt można rozszerzyć o następujące funkcjonalności:

\begin{enumerate}
	\item \textbf{Dodanie kolejnych gier} - obecna architektura projektu umożliwia rozszerzenie aplikacji o kolejne gry logiczne, które spełniają założenia algorytmu UCT. Zwiększenie liczby dostępnych gier poszerzyłoby możliwości dokładniejszego badania algorytmu UCT.
	\item \textbf{Usprawnienie i zrównoleglenie symulacji szachów} - symulacja ruchu szachowego przez komputer zajmuje dużo więcej czasu w przypadku szachów niż mankali. Zrównoleglenie pewnych obliczeń szachowych, które zajmują najwięcej czasu, poprawiłoby jakość decyzji podejmowanych przez algorytm w jednostce czasu.
	\item \textbf{Dodanie otwarć szachowych} - algorytm UCT dla niewielkiej liczby iteracji ma tendencję do wybierania ruchów dających natychmiastowe wynagrodzenie, tym samym ignorując ruchy, które niebezpośrednio prowadzą do lepszych, złożonych zagrań. To oznacza, że algorytm podejmuje lepsze decyzje w końcowym stadium rozgrywki, niż w początkowym --- szczególnie dobrze widać to w przypadku rozgrywki szachowej. Możliwe byłoby zatem wprowadzenie usprawnienia w postaci zbioru sprawdzonych szachowych rozwiązań dotyczących rozpoczęcia rozgrywki, z których korzystałby komputer przy wyznaczaniu początkowych ruchów.
	\item \textbf{Lepsza ewaluacja wartości figur w szachach} - sposób wartościowania figur jest miejscem, w którym można znacznie rozwinąć potencjał decyzji podejmowanych przez algorytm UCT. Na ten moment każda figura ma arbitralnie ustaloną wartość, bez względu na swoje położenie na szachownicy. Tymczasem, wartość danej figury może zależeć od wielu czynników, między innymi od pozycji, w której się znajduje. Dla przykładu, skoczek w centrum planszy będzie miał większy potencjał od takiego, który umieszczony jest w rogu. Tak samo pion, który jest bliżej ostatniego rzędu pól, jest bardziej wartościowy od piona na swojej początkowej pozycji, a pion zdublowany prawdopodobnie jeszcze mniej. Liczba konfiguracji i czynników wpływających na potencjał figury w danym miejscu na szachownicy wykracza poza temat tej pracy, jednak potencjalne rozwinięcie lepiej przemyślanej ewaluacji figur wpłynęło by korzystnie na zdolność algorytmu do podejmowania bardziej obiecujących ruchów.
	\item \textbf{Inteligentne przydzielanie pamięci dla drzew w sekwencji} - podczas przełączania się pomiędzy kolejnymi drzewami w sekwencji, za każdym razem następuje wczytanie do pamięci podręcznej wartości i pozycji wszystkich węzłów danego drzewa. Oznacza to, że jeśli użytkownik analizuje dwa kolejne drzewa i przełącza między nimi na zmianę, za każdym razem te same drzewa są wczytywane do pamięci podręcznej na nowo. Usprawnieniem tego procesu byłoby przechowywanie wcześniej już wczytanych drzew, jednocześnie automatycznie kontrolując ilość wykorzystanych zasobów. Co więcej, program mógłby wczytywać od razu pewną liczbę kolejnych drzew z wyprzedzeniem. Takie operacje zaoszczędziłyby czas użytkownika, zwłaszcza podczas wczytywania drzew z dużą ilością węzłów.
\end{enumerate}

Czynnikiem wpływającym negatywnie na szybkość wykonywania obliczeń w języku Python jest fakt, że jest to język interpretowany. W celu przyspieszenia modułu odpowiedzialnego za grę w szachy, można by przepisać go w całości z języka Python do języka kompilowanego.